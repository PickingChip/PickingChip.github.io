# 通信协议

### 1.串口通信：

串口通信属于全双工串行通信，分为异步（无时钟线）和同步（有）两种通讯方式，F1开发板有五个串口1，2(usart)支持两种方式，剩下的（uart）仅支持异步通讯.

如果选用异步通讯需要设置通讯双方的波特率一致，大小为`baud=fck/16∗USARTDIV`。

- fck为串口接入的系统时钟频率（2，3，4，5为PCLK1，1为PCLK2）

- USARTDIV为寄存器设置的值

串口缓存寄存器（usart—DR）分为两个寄存器输入缓存寄存器和输出缓存寄存器，他们通过并行连接的方式与总线和数据位移寄存器相连。

串口通信有检验位，总共有四种检验方式，奇检验，偶检验，0检验，1检验

串口的硬件结构：

![usart](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/usart.png)

串口的中断：

![usart中断](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/usart%E4%B8%AD%E6%96%AD.png)

### 2.IIC(Inter-Integrated Circuit) 通信：

概括：IIC总线是一种两线式串行总线，由数据线SDA和时钟线SCL组成，默认情况下两条总线均为高电平，两条总线上可以挂载多设备，支持多主多从，半双工通信。

信号：

1.起始信号：在时钟线为高电平期间，数据线由高电平转变为低电平，由主机发出表明对主线进行占用，准备进行数据传输

2.停止信号：时钟线为高电平期间，数据线由低电平转变为高电平，由主机发出表明放弃对总线的占用。

3.应答信号：发送器每传输一字节数据（8个时钟脉冲）就会在第九个时钟脉冲期间释放对数据总线的控制（此时总线默认回到高电平状态）等待接收器给一个应答信号，如果接受器在第九个时钟脉冲期间将数据总线拉低，就说明接受器已经成功接收到上一个字节的数据（有效应答），否则数据总线则为高电位证明没有接受到上一字节的数据（无效应答）。

两根总线在最开始状态均为高电位，有起始信号后电位开始改变，数据传输过程中数据总线上电位的改变总是在时间总线低电位期间改变，高电位期间维持稳定（防止产生起始/终止信号）

IIC的结构：

![IIC](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/IIC.png)

IIC中断：

![IIC中断](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/IIC%E4%B8%AD%E6%96%AD.png)

注意：SB 、 ADDR 、 DDIO 、 STOPF 、 BTF 、 RxNE 和TxE ，通过逻辑或映射到同一个通道上。BERR、 ARLO 、 AF 、 OVR、 PECERR 、TIMEOU T和 SMBALERT通过逻辑或映射到同一个中断通道上。

通信过程：

主机在发送起始信号后会发送从机地址组成（7bit或者10bit根据模式选择），总线上的所有设备都会接受这个地址然后通过比较器于自己的地址作比较，如果发现是自己的地址之后就会发出响应，主机在接收到从机的响应之后就会接着进行数据的传输，之后从机每接收一个字节之后都会返回1bit响应信号来告诉从机时候成功接收。

![IIC1](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/IIC1.png)

![IIC2](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/IIC2.png)

IIC模式：

IIC通信的实现通常通过GPIO模拟IIC时序的和使用IIC外设两种方式：

软件IIC的实现可以参考整点原子例程使用GPIO模拟电平信号的方法实现。

### 3.SPI（Serial Peripheral interface ）通信：

概括：SPI通信需要3+n(从机个数)条总线，仅支持一主多从，传输方式有单双工，半双工，全双工三种方式。

工作原理：

主机和从机都有一个串行移位寄存器，主机通过向它的 SPI 串行寄存器写入一个字节来发起一次传输。串行移位寄存器通过 MOSI 信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中的内容就被交换。外设的写操作和读操作是同步完成的。如果只是进行写操作，主机只需忽略接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。

![SPI1](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/SPI1.png)

引脚：

1. MISO（Master In / Slave Out）主设备数据输入，从设备数据输出。
2. MOSI（Master Out / Slave In）主设备数据输出，从设备数据输入。
3. SCLK（Serial Clock）时钟信号，由主设备产生。
4. CS（Chip Select）从设备片选信号，由主设备产生，默认状态下该引脚为高电平，当主机想与从机通讯时，从机的该引脚电平会被拉低从而被主机选中（每一个从机都有一个用于片选定的总线）

工作模式：

时钟极性CPOL有两种状态，CPOL=1/0时，空闲状态下时钟线SCL为高电平/低电平

时钟相位CPHA有两种状态，CPHA=1/0时，数据传输过程中数据线上的数据在时钟脉冲的偶数/奇数边缘采样

两者组合SPI就有了四种工作模式，同时一个数据帧是8位还是16位由SPI_CR1决定

### 4.CAN通信协议

江科大CAN通信（讲的很清楚）：[江科CAN通信](https://www.bilibili.com/video/BV1vu4m1F7Gt/?spm_id_from=333.999.0.0)

CAN（Controller Area Network ）通信协议**利用差分信号进行半双工异步通信**（差分信号抗干扰性强），支持多主多从。分为高速CAN通信（节点挂在一个回环电路上电路两端各需要一个120欧的电阻，最大传输速率为1Mbps，最远40m），低速CAN通信（挂载在两根线上，每根线上需要一个2.2千欧的电阻，最远可达10KM，速率低于5Kbps）。每一个节点分为CAN控制器和CAN收发器组成，控制器通过GPIO引出CAN*TX和CAN*RX与收发器连接，收发器与总线相连。

CAN控制器的结构：

![CAN1](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/CAN1.png)

过滤器：

过滤器有两个32位的核心寄存器，根据不同的配置方法有四种模式：

- 32位屏蔽模式 （可以过滤特定位相同的一类报文ID，第一个寄存器写目标ID，第二个寄存器将要过滤的报文ID必须和第一个寄存器中ID相同的位 置1）
- 16位屏蔽模式（一个过滤器可以过滤两种类型的标准帧ID）
- 32位列表模式（只有接收到的报文ID和两个寄存器中的ID完全相同才能通过，可选过滤标准帧或是拓展帧，但是每个过滤器只能过滤两种报文）
- 16位列表模式（和上面的相似可以过滤四种ID，但是只能过滤标准帧）

发送邮箱：

发送邮箱其实就相当于是缓存，当CPU写入速度大于CAN发送速度时，为了防止阻塞就可以把数据缓存在各个邮箱里，等控制器有空并且总线空闲时就可以，根据优先级（或者先来后到）对邮箱里的数据进行发送。

接收邮箱：

接收邮箱相当于接收缓存（两个队列），当读取速度小于接受速度时起作用，每一个过滤器都可以配置将过滤后的报文发送到哪个邮箱队列（0或者1），读取时按照先进显出的规则进行，同时队列满时你可以配置是将后续接收到的报文丢弃还是将队列最后一个报文替换。

三种调试模式：

![CAN2](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/CAN2.png)

三种工作模式：

![CAN3](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/CAN3.png)

CAN也可以申请中断：

![CAN4](https://pickingchip.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F/Stm32/Picture/CAN4.png)